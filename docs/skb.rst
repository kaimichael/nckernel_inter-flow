Socket Buffers
==============

Socket buffers are used to pass payload to and from the coders. The socket
buffer is similar to the structure of the same name of the Linux kernel. The
socket buffer is usually used with the following steps:

1. Reserve space for the headers at the current layer
2. Pass the socket buffer to a lower layer to fill the payload
3. Add header data

This procedure allows to add header data at any point in time without requiring to copy
the payload, as long as enough header space was reserved.

Creating an Empty Socket Buffer
-------------------------------

When an application wants to send out a packet generated by one of the nckernel
protocols, an empty socket buffer must be created.  First a memory buffer needs
to be allocated.  Then this memory is passed to the :c:func:`skb_new` function
to initialize the buffer.  The following example shows the steps required to
initialize a new socket buffer.

.. code:: c

    struct sk_buff skb;
    uint8_t buffer[1500];
    skb_new(&skb, buffer, sizeof(buffer);

Creating a Socket Buffer with Payload
-------------------------------------

When an application receives a packet from the outside and wants to pass it to
a protocol, a socket buffer must be created which contains the received
payload.  We start by creating an empty socket buffer. Then we receive the
packet into the socket buffer.  The following example shows the necessary
steps, assuming we receive the data from a UDP socket.

.. code:: c

    struct sk_buff skb;
    uint8_t buffer[1500];
    skb_new(&skb, buffer, sizeof(buffer));
    ssize_t len = recv(sock, skb.data, skb_tailroom(&skb), 0);
    skb_put(&skb, len);


Header Structures
-----------------

The recommended approach is to create a structure containing all header values.
Each field in the structure should be aligned according to its size. That
means, 16 bit values should be aligned to 16 bits and 32 bit values to 32 bits.
Dummy fields may be inserted into the structure to achieve this alignment. This
allows to use aligned reads for all values, which on some architectures is just
faster, but also in some architectures only aligned reads are possible. The
following code shows the header structure used in the remaining examples.

.. code:: c

    struct my_header {
        uint8_t value1;
        uint8_t _reserved;
        uint16_t value2;
        uint32_t value3;
    };

Writing to the Socket Buffer
----------------------------

The functions :c:func:`skb_push` and :c:func:`skb_put` can be used to add data
to a socket buffer. With :c:func:`skb_push` data is added to the header, while :c:func:`skb_put`
appends data to the end of the buffer. The following code gives a full example of
implementing one protocol layer.

First, we reserve space for the header. Then we just pass the socket buffer to
the higher layer. We populate the header only after the higher layer is
finished.  This allows the lower layer to have all freedoms to reserve headers,
since this is only possible on an empty socket buffer. We then populate our
header by calling :c:func:`skb_push` and convert the returned pointer to a
pointer to our header structure. We can then directly populate the fields in
our header structure.  It is recommended to transport all values in network
byte order. To convert from host byte order to network byte order we use the
functions ``htons`` (Host TO Network Short) and ``htonl`` (Host TO Network Long).

.. code:: c

    void write_layer2(struct sk_buff *skb) {
        struct my_header *header;
        skb_reserve(skb, sizeof(*header));

        write_layer3(skb);

        header = skb_push(skb, sizeof(*header));

        header->value1 = 1;
        header->value2 = htons(2);
        header->value3 = htonl(3);
    }

Reading from the Socket Buffer
------------------------------

The function :c:func:`skb_pull` can be used to read data from the header of the
payload.  The following code gives a canonical example for reading the headers
of one protocol layer and passing the remaining payload to the higher layer.
First, we check if enough space is available with :c:func:`pskb_may_pull`.
Then we directly convert the pointer to the head of the data to a pointer to
the header structure. Then we update the socket buffer with :c:func:`skb_pull`.
After this, everything is sane and we can pass the socket buffer to the higher
layers. However, it is recommended, that all values in the header structure are
presented in network byte order. To get the values into the native byte order
use the functins ``ntohs`` (Network TO Host Short) and ``ntols`` (Network TO
Host Long).

The following code shows the full example code.

.. code:: c

    void read_layer2(struct sk_buff *skb) {
        struct my_header *header;
        assert(pskb_may_pull(skb, sizeof(*header)));
        header = (struct my_header*)skb->data;
        skb_pull(skb, sizeof(*header));

        uint8_t value1 = header->value1;
        uint16_t value2 = ntohs(header->value2);
        uint32_t value3 = ntols(header->value3);

        // some processing ...

        read_layer3(skb);

        // maybe more processing ...
    }

API
---

.. kernel-doc:: include/nckernel/skb.h
