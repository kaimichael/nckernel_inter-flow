#ifndef _NCK_sw_H_
#define _NCK_sw_H_

#include "api.h"

#ifdef __cplusplus
extern "C" {
#endif

struct nck_sw_enc;
struct nck_sw_dec;
struct nck_sw_rec;
struct nck_timer;

/**
 * nck_sw_create_enc - creates a encoder for the sw protocol
 *
 * @encoder: encoder structure that will be configured
 * @timer: timer implementation that will be used by the encoder
 * @context: configuration context (e.g. a file, a dict structure, ...)
 * @get_opt: a function to extract a configuration value from the context
 */
int nck_sw_create_enc(struct nck_encoder *encoder, struct nck_timer *timer, void *context, nck_opt_getter get_opt);
/**
 * nck_sw_create_dec - create a decoder for the sw protocol
 *
 * @decoder: decoder structure that will be configured
 * @timer: timer implementation that will be used by the encoder
 * @context: configuration context (e.g. a file, a dict structure, ...)
 * @get_opt: a function to extract a configuration value from the context
 */
int nck_sw_create_dec(struct nck_decoder *decoder, struct nck_timer *timer, void *context, nck_opt_getter get_opt);
/**
 * nck_sw_create_rec - create a decoder for the sw protocol
 *
 * @recoder: recoder structure that will be configured
 * @timer: timer implementation that will be used by the encoder
 * @context: configuration context (e.g. a file, a dict structure, ...)
 * @get_opt: a function to extract a configuration value from the context
 */
int nck_sw_create_rec(struct nck_recoder *recoder, struct nck_timer *timer, void *context, nck_opt_getter get_opt);

struct nck_sw_enc *nck_sw_enc(uint32_t symbols, uint32_t symbol_size, struct nck_timer *timer, const struct timeval *timeout);
/**
 * nck_sw_dec - allocate a new decoder for the sw protocol
 *
 * @symbols: maximum number of symbols in the decoder window.
 * @symbol_size: maximum size of a single symbol
 * @timer: interface to a timer. If NULL then no timeouts will be used.
 * @timeout: time until a decoder timeout. If NULL then no timeout will be used.
 * @algorithm: name of the decoding algorithm to use: band (default), echelon.
 */
struct nck_sw_dec *nck_sw_dec(uint32_t symbols, uint32_t symbol_size, struct nck_timer *timer, const struct timeval *timeout, const char *algorithm);
struct nck_sw_rec *nck_sw_rec(uint32_t symbols, uint32_t symbol_size, struct nck_timer *timer, const struct timeval *timeout);

/**
 * Sets the initial sequence number of the decoder.
 *
 * @encoder: decoder structure to configure
 * @sequence: Initial sequence number
 */
void nck_sw_dec_set_sequence(struct nck_sw_dec *decoder, uint32_t sequence);
/**
 * Sets the sequence number of the encoder.
 *
 * @encoder: encoder structure to configure
 * @sequence: Initial sequence number
 */
void nck_sw_enc_set_sequence(struct nck_sw_enc *encoder, uint32_t sequence);
/**
 * Set the current forward code window.
 *
 * The encoding window is opened with every added new symbol and will automatically
 * be closed according to the given window size.
 *
 * @encoder: encoder structure to configure
 * @forward_code_window: Size of the forward code window
 */
void nck_sw_enc_set_forward_code_window(struct nck_sw_enc *encoder, uint32_t forward_code_window);
/**
 * Set the current forward code window.
 *
 * The recoding window is advanced with newer incoming symbols or feedback with higher sequence
 * numbers. Coded packets generated by the recoder will only include symbols from its internal
 * symbol storage which have coefficients covered by the forward code window, or which are requested
 * in a feedback.
 *
 * This should create ''sparse'' coded symbols where coefficients referring to older original symbols
 * are zero.
 *
 * @recoder: recoder structure to configure
 * @forward_code_window: Size of the forward code window
 */
void nck_sw_rec_set_forward_code_window(struct nck_sw_rec *recoder, uint32_t forward_code_window);
/**
 * Set the length of the systematic phase.
 *
 * This is the number of uncoded packets that will be sent before the next coded packet.
 * For example setting this to 3 ensures that every 3 packets a coded packet is sent.
 *
 * @encoder: encoder structure to configure
 * @phase_length: number of uncoded packets to send in a row
 */
void nck_sw_enc_set_systematic_phase(struct nck_sw_enc *encoder, uint32_t phase_length);
/**
 * Set the length of the coded phase.
 *
 * This is the number of coded packets that will be sent before the next uncoded packet.
 *
 * @encoder: encoder structure to configure
 * @phase_length: number of coded packets to send in a row
 */
void nck_sw_enc_set_coded_phase(struct nck_sw_enc *encoder, uint32_t phase_length);
/**
 * Enable coded retransmissions.
 *
 * With this setting enabled retransmissions will always be coded. The encoder will count the
 * missing packets and sends as many coded packets in a retransmission.
 *
 * @encoder: encoder structure to configure
 * @coded_retrans: 1 to enable and 0 to disable
 */
void nck_sw_enc_set_coded_retransmissions(struct nck_sw_enc *encoder, int coded_retrans);
/**
 * Set the length of the feedback period.
 *
 * This configuration defines how often feedback requests are sent. For example
 * a value of 1 indicates that every packet is acknowledged. A value of 4 means
 * every fourth packet requests an acknowledgement.
 *
 * To disable acknowledgements set this value to zero. Then the decoder can still
 * send negative acknowledgements.
 *
 * @encoder: encoder structure to configure
 * @period: distance between acknowledgement requests
 */
void nck_sw_enc_set_feedback_period(struct nck_sw_enc *encoder, uint32_t period);
/**
 * Enables or disables feedback on missing symbols
 *
 * This configuration defines how often feedback requests are sent. The actual
 * feedback period is controlled by the encoder but the decoder should also
 * not sent any feedback when feedback is disabled and a symbol was detected
 * as missing.
 *
 * @decoder: decoder structure to configure
 * @enable: whether feedback on missing symbol is active
 */
void nck_sw_dec_set_feedback(struct nck_sw_dec *decoder, uint32_t enable);
/**
 * Enables or disables feedback on missing symbols
 *
 * This configuration defines how often feedback requests are sent. The actual
 * feedback period is controlled by the encoder but the decoder should also
 * not sent any feedback when feedback is disabled and a symbol was detected
 * as missing.
 *
 * @recoder: decoder structure to configure
 * @enable: whether feedback on missing symbol is active
 */
void nck_sw_rec_set_feedback(struct nck_sw_rec *recoder, uint32_t enable);
/**
 * Set the size of the encoder memory
 *
 * The memory remembers the sent coded packets. A short memory will result in
 * earlier retransmissions. A long memory results in better efficiency, since
 * retransmissions are triggered only when really needed.
 *
 * @encoder: encoder structure to configure
 * @memory: number of coded packets to remember
 */
void nck_sw_enc_set_memory(struct nck_sw_enc *encoder, uint32_t memory);
/**
 * Set the number of transmission attempts per source symbol
 *
 * @encoder: encoder structure to configure
 * @tx_attempts: maximum number of transmission attemps
 */
void nck_sw_enc_set_tx_attempts(struct nck_sw_enc *encoder, uint8_t tx_attempts);
/**
 * Set the number of transmission (flush) attempts per innovative packet
 *
 * @recoder: recoder structure to configure
 * @tx_attempts: maximum number of transmission attemps
 */
void nck_sw_rec_set_tx_attempts(struct nck_sw_rec *recoder, uint8_t tx_attempts);
/**
 * Set the number of transmission attempts per feedback
 *
 * @decoder: decoder structure to configure
 * @tx_attempts: maximum number of transmission attemps
 */
void nck_sw_dec_set_tx_attempts(struct nck_sw_dec *decoder, uint8_t tx_attempts);
/**
 * Set the number of redundant packets.
 *
 * The given number is meant as redundant packets per generation. The redundant
 * packets will be evenly distributed within a generation.
 *
 * @encoder: encoder structure to configure
 * @redundancy: redundant packets per generation
 */
void nck_sw_enc_set_redundancy(struct nck_sw_enc *encoder, int32_t redundancy);
/**
 * Set the number of redundant packets.
 *
 * The given number is meant as redundant packets per generation. The redundant
 * packets will be evenly distributed within a generation.
 *
 * @recoder: recoder structure to configure
 * @redundancy: redundant packets per generation
 */
void nck_sw_rec_set_redundancy(struct nck_sw_rec *recoder, int32_t redundancy);
/**
 * Set the feedback timeout
 *
 * Feedbacks are generated after the specified time after a packet has been received.
 * Also the last feedback sent will rearm the timer if the generation isn't complete yet.
 *
 * @decoder: decoder structure to configure
 * @fb_timeout: feedback timeout
 */
void nck_sw_dec_set_fb_timeout(struct nck_sw_dec *decoder, struct timeval *fb_timeout);
/**
 * Set the feedback only on repair mode
 *
 * instead of asking the decoder for feedback on several occurences, this mode only sets
 * the feedback requested flag if a repair packet is sent.
 *
 * @decoder: decoder structure to configure
 * @feedback_only_on_repair: flag to set the mode
 */
void nck_sw_enc_set_feedback_only_on_repair(struct nck_sw_enc *encoder, uint32_t feedback_only_on_repair);

NCK_ENCODER_API(nck_sw)
NCK_DECODER_API(nck_sw)
NCK_RECODER_API(nck_sw)

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _NCK_sw_H_ */
